# -*- coding: utf-8 -*-
"""delOutlier_2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T600f9pYlE6ufLDDoePUyY11gIGn-v57

# 串接雲端
資料需要事先傳到雲端，並執行下面程式碼，點選該雲端，複製驗證碼後，貼上執行後出現的方匡內，即可驗證完畢。

第一次執行時間需等待較久，為正常情況。
"""

from google.colab import drive
drive.mount('/content/drive')

"""# 載入函示庫"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from math import sqrt

"""# 模型說明
Model 11 = 適當的控制變數  Core_Technological_Coherence  Core_Technological_Coherence^2 Technological_distance  Core_Technological_Coherence* Technological_distance Core_Technological_Coherence^2* Technological_distance

Y 1 = forward citation ranking_prior 5 years(fixed effect adjust) top 3%

***注意事項***
1. 資料需要事先存到雲端
2. 資料需存為xlsx檔
3. 資料標頭要小心是否有空格，建議一率從excel複製，不要自己打
4. 資料若有缺失值，需統一將缺失值都設定為***，可以只修改會用到的變數即可
5. 全部程式碼只需更動下面這一個，將相關設定成自己的，其他都不需要更動，執行就好！
"""

# 設定資料（唯一需要修改的地方）

# 回歸：控制變數＆Ｘ
var = ['Ln_Firm_age ','Ln_firm_size(emp)',' R&D_intensity(xrd/ sale) ','Ln number of alliances','Ln Patent stock','CTC_edited','CTC^2','technological distance_edited','CTC*Technology distance','CTC^2*Technology distance']
# 回歸：Ｙ
DV = 'forward citation ranking_prior 5 years(fixed effect adjust) top 3%'
# 讀入excel檔案的路徑
input_path = r"/content/drive/MyDrive/data_MS/資料總檔/新財務變數/CTC模型/excel檔案/telecommunication_0826.xlsx"
# 匯出excel檔案的路徑
output_path = r"/content/drive/MyDrive/data_MS/資料總檔/新財務變數/CTC模型/excel檔案/del_telecommunication_0826.xlsx"

# 載入存在雲端的資料（xlsx檔）
df = pd.read_excel(input_path, keep_default_na=False)

# 確認資料是否正確
df

# 刪除含有缺失值的列（缺失值需統一設定成***）
df_isNA = df
for v in var:
  df_isNA = df_isNA.loc[df_isNA[v] != "***" ]

df_isNA = df_isNA.reset_index(drop=True)

# 確認資料是否正確刪除含缺失值的列
df_isNA

"""# 多元回歸，刪除outliers

執行多元回歸，每一次回歸刪除最大殘差的觀察值，然後再次執行，直到沒有outliers
"""

# 刪掉觀察值的數量
count = 0

# 執行多元回歸
while True:

  # 設定回歸的Ｘ& Y
  X = df_isNA[var]
  y = df_isNA[DV].values
  #print(X.shape, y.shape)
  
  # 多元回歸
  X2 = sm.add_constant(X) 
  res = sm.OLS(y, X2.astype(float)).fit()
  beta = res.params
  #print(res.summary()) #總回歸分析與檢驗
  #print(res.params) #beta值  

  # 檢查Beta值，如果beta = 0，則不能做回歸，實驗結束。
  sum_beta = 0
  for i in range(len(beta)):
    sum_beta = sum_beta+beta[i]
  if sum_beta==0:
    print("all beta = 0", "實驗結束！")
    break

  # 計算每筆觀察值的標準殘差，以利分辨outlier
  y_array = y.ravel()
  #估計值
  predict = res.predict() 
  predict_array = np.array(predict)
  #殘差
  subtract = y_array-predict_array
  #標準化估計 ((Σ(y-y')^2)/n)^1/2
  std_predict = sqrt(sum(np.square(subtract))/len(y_array)) #殘差
  #標準殘差 = 殘差/標準化估計值
  std_subtract = subtract/std_predict

  # 取最大的標準殘差在第幾筆
  std_subtract_list = std_subtract.tolist()
  max_std_index = std_subtract_list.index(max(std_subtract_list))

  # 確認是否有標準殘差>3的觀察值
  num_tempOutlier = 0
  #如果有，則 num_tempOutlier > 0
  for i in range(len(std_subtract)):
    if std_subtract[i]>3.5:
      num_tempOutlier = num_tempOutlier + 1

  # 如果有，則刪除標準殘差最大的那列觀察值
  if num_tempOutlier > 0:
    df_isNA = df_isNA.drop([max_std_index],axis=0)
    df_isNA= df_isNA.reset_index(drop=True)
    count = count+1
  # 如果沒有，則實驗結束
  else:
    break

"""# 確認成功刪除outliers"""

# 確認刪除後的X&y的大小
X.shape, y.shape

#確認刪除多少個outliers
count

"""#匯出excel檔案"""

# 儲存excel檔案
df_isNA.to_excel(output_path, header=True)

